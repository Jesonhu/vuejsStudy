<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="../../js/vue.min.js"></script>
</head>
<body>
    <!--简单状态管理起步使用****************************************
        经常被忽略的是，Vue 应用中原始 数据 对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。
        所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享：
        const sourceOfTruth = {}
        const vmA = new Vue({
          data: sourceOfTruth
        })
        const vmB = new Vue({
          data: sourceOfTruth
        })
        现在当 sourceOfTruth 发生变化，vmA 和 vmB 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 this.$root.$data 去访问。
        现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。

        为了解决这个问题，我们采用一个简单的 store 模式：
        var store = {
          debug: true,
          state: {
            message: 'Hello!'
          },
          setMessageAction (newValue) {
            this.debug && console.log('setMessageAction triggered with', newValue)
            this.state.message = newValue
          },
          clearMessageAction () {
            this.debug && console.log('clearMessageAction triggered')
            this.state.message = 'clearMessageAction triggered'
          }
        }
        需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。
        这种集中式状态管理能够被更容易地理解哪种类型的 mutation(变化转变) 将会发生，
        以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。
        
        state状态就是数据源，通常用data，view是视图层不用说，通常用template，action就是方法进行一些数据操作，通常用methods

        每个实例/组件仍然可以拥有和管理自己的私有状态
        -->
</body>
</html>
